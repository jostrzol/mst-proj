---
title: "Survey analysis"
format:
  html:
    code-fold: true
    echo: false
jupyter: python3
---

```{python}
# | echo: false

# pyright: reportUnusedCallResult=false
# pyright: reportUnknownVariableType=false

from collections.abc import Iterable
import os
import matplotlib.pyplot as plt
from matplotlib.ticker import PercentFormatter
import pandas as pd
import numpy as np
import scienceplots


from enum import Enum
from pathlib import Path
from typing import Any, Callable, override
from matplotlib.axes import Axes
from IPython.display import display

from lib.plot import savefig
from lib.constants import PLOT_DIR


_ = scienceplots
plt.style.use(["science", "ieee", "notebook"])
plt.rcParams["figure.dpi"] = 100


def find_root_dir():
    start_path = Path(__file__).parent if "__file__" in globals() else Path.cwd()
    current = start_path
    while current != current.parent:
        if (current / ".git").exists():
            return current
        current = current.parent
    return start_path


ROOT_DIR = find_root_dir()
SURVEY_PATH = ROOT_DIR / "analysis-src/survey.csv"
OUT_DIR = PLOT_DIR / "survey"

os.chdir(ROOT_DIR)
OUT_DIR.mkdir(exist_ok=True)


class Column(Enum):
    "Columns in the survey dataframe"

    TIMESTAMP = "Timestamp"

    # Section 1: Demographics and role
    S1_INDUSTRY = "Industry segment"
    S1_ROLE = "Your primary role"

    # Section 2: Current language usage
    S2_LANGUAGES_USED = """Which programming languages do you currently use or have used in the past
    for microcontroller projects?"""
    S2_C_CPP_RATIO = "What ratio of your embedded codebase is in C/C++?"

    # Section 3: Pain points and challenges
    S3_PERFORMANCE = "Real‑time performance"
    S3_DEBUGGING = "Debugging microcontroller programs"
    S3_LEGACY = "Integration with legacy code"
    S3_HARDWARE = "Interacting with hardware"
    S3_MEMORY = "Memory constraints (binary size, RAM/flash usage)"
    S3_MEMORY_SAFETY = "Memory vulnerabilities (e.g. use after free, buffer overflows)"
    S3_POWER = "Power consumption management"
    S3_CERTIFICATION = "Safety certification (e.g. IEC 61508, ISO 26262)"
    S3_TOOLING = "Tooling complexity (e.g. build system)"

    # Section 4: Language selection criteria
    S4_LIBRARIES = "Availability of libraries"
    S4_C_INTEROPERABILITY = "Interoperability with C code"
    S4_MATURITY = "Maturity of compiler/toolchain"
    S4_PERFORMANCE = "Real-time performance"
    S4_MEMORY_SAFETY = "Safety of memory management"
    S4_COMMUNITY = "Strong community support"
    S4_TRAINING = "Team expertise and training cost"
    S4_TOOLING = "Tooling features and usability (e.g. build system)"

    # Section 5: Modern language adoption
    S5_DID_USE_MODERN = "Have you ever used any “modern” language (e.g. Rust, Zig) for embedded development?"
    S5_BARRIERS = "If not, what barriers prevent you?"
    S5_MODERN_ADOPTION = (
        "How likely are you to adopt any “modern” language in the next 12 months?"
    )

    # Section 6: Tooling and ecosystem
    S6_BUILD_SYSTEM_SATISFACTION = """Rate your satisfaction with the build system for C/C++ that you use for
    embedded projects."""
    S6_STATIC_ANALYSIS_RELIANCE = """How much do you rely on C/C++ static analysis tools for microcontroller
    code? (e.g. clang-tidy, MISRA checkers)"""
    S6_STATIC_ANALYSIS_SATISFACTION = """Rate your satisfaction with C/C++ static analysis tools for
    microcontroller code."""

    # Section 7: Open section
    S7_WANTED_FEATURES = """Can you think of any language or tooling features would most help your
    embedded development?"""
    S7_COMMENTS = "Any additional comments?"

    @override
    def __str__(self) -> str:
        return self.name
```

```{python}
df = pd.read_csv(SURVEY_PATH)
df.columns = [column for column in Column]
display(df.head())
```

```{python}
# | echo: false


def preprocess(
    series: pd.Series,
    replace: dict[Any, Any | list[Any]] | None = None,
    drop: list[Any] | None = None,
) -> pd.Series:
    replace = replace or {}

    def replace_value(value: Any) -> list[Any]:
        replacement = replace.get(value, value)
        return replacement if isinstance(replacement, list) else [replacement]

    def preprocess_row(lst: list[Any]) -> list[Any]:
        series = pd.Series(lst)
        series = series.map(replace_value).explode()
        series = series[~series.isin(drop or [])]
        return series.to_list()

    return series.apply(preprocess_row)


def plot_hist(
    series: pd.Series,
    range: Iterable[Any] | None = None,
    rotation: bool | float = False,
    sort_by_index: bool = False,
    format: Callable[[Any], Any] | None = None,
    xlabel: str | None = None,
    xmargin: float = 0,
    xtick_fontsize: int = 16,
) -> Axes:
    series = series.explode()  # in case multichoice
    values = series.value_counts()
    for label in range or []:
        if label not in values:
            values[label] = 0
    if sort_by_index:
        values = values.sort_index()
    if format:
        labels = values.index.map(format)
        values.index = labels

    ax = values.plot(kind="bar", xlabel=xlabel or "")

    ax.tick_params(axis="x", bottom=False)
    ax.tick_params(axis="x", which="minor", bottom=False)

    if rotation == True:
        plt.setp(ax.get_xticklabels(), rotation=45, ha="right", fontsize=xtick_fontsize)
    elif rotation != False:
        plt.setp(ax.get_xticklabels(), rotation=rotation, fontsize=xtick_fontsize)
    else:
        plt.setp(ax.get_xticklabels(), rotation=0, fontsize=xtick_fontsize)

    for i, v in enumerate(values):
        ax.text(i, v + 0.1, str(v), ha="center", va="bottom", fontsize=16)

    ax.set_ylim(top=max(values) * 1.09)
    ax.yaxis.set_major_formatter(PercentFormatter(decimals=0))

    xmin, xmax = ax.get_xlim()
    xmargin = xmargin * (xmax - xmin)
    ax.set_xlim(xmin - xmargin, xmax + xmargin)

    if series.name is not None:
        savefig(plt.gcf(), OUT_DIR / str(series.name))

    return ax


def plot_pie(series: pd.Series, label: str | None = None) -> Axes:
    values = series.value_counts()
    total = values.sum()

    def fmt(percent: np.float64):
        count = (percent / 100 * total).astype(np.int64)
        return f"{count} ({percent:.0f}%)"

    gray_shades = [f"{shade:.2f}" for shade in np.linspace(0.9, 0.6, len(values))]

    ax = values.plot(
        kind="pie",
        autopct=fmt,
        label=label or "",
        colors=gray_shades,
        wedgeprops={"edgecolor": "black", "linewidth": 2},
        textprops={"fontsize": 16},
        explode=[0.03] * len(values),
    )

    return ax


ax: Axes
df_out = pd.DataFrame()
```

## Section 1: Demographics and role

### Industry segment

```{python}
column = Column.S1_INDUSTRY
values = df[column].str.split(";")


values = preprocess(
    values,
    replace={
        "Material Handling (Forklifts)": "Automotive",
        "Transport": "Automotive",
        "Silicon photonics and lasers": "Silicon production",
        "Fabless semiconductor company": "Silicon production",
        "Computer networking": "Networks",
        "Telecoms": "Networks",
        "IMS": "Networks",
        "Wireless charging": "Consumer electronics",
        "Stage lighting equipment": "Professional electronics",
        "Professionnel Photography/Lighting": "Professional electronics",
        "test and measurements": "Professional electronics",
        "Metering": "Professional electronics",
        "Datacenter": "Professional electronics",
        "Hobby": "Consumer electronics",
        "Scientific Research Instrumentation": "Research",
    },
    drop=["Software Development", "Open Source"],
)
df_out[column] = values

plot_hist(values, rotation=True, xlabel="")
plt.show()
```

### Primary role

```{python}
column = Column.S1_ROLE
values = df[column]

values = preprocess(
    values,
    replace={
        "Hardware and Software": ["Software engineer", "Hardware engineer"],
        "Both hard and software (firmware)": ["Software engineer", "Hardware engineer"],
        "HW / SW engineer": ["Software engineer", "Hardware engineer"],
        "all of the above": [
            "Software engineer",
            "Hardware engineer",
            "System architect",
        ],
    },
)
df_out[column] = values
plot_hist(values, xtick_fontsize=15)
plt.show()
```

## Section 2: Current language use

### Language use

```{python}
# | echo: false
# | output: 'asis'

column = Column.S2_LANGUAGES_USED
print(f"*{column.value}*")
```

```{python}
column = Column.S2_LANGUAGES_USED
values = df[column].str.split(";")

values = preprocess(
    values,
    replace={
        "JavaScript / TypeScript (e.g. Espruino)": "JavaScript / TypeScript",
        "Assembler": "Assembly",
        "Bash": "Shell scripts",
        "scheme, forth, Dylan": ["Scheme", "Forth", "Dylan"],
    },
)
df_out[column] = values
plot_hist(values, rotation=True, xmargin=0.02)
plt.show()
```

### Codebase

```{python}
# | echo: false
# | output: 'asis'

column = Column.S2_C_CPP_RATIO
print(f"*{column.value}*")
```

```{python}
column = Column.S2_C_CPP_RATIO
values = df[column]
df_out[column] = values

plot_hist(
    values,
    rotation=True,
    sort_by_index=True,
    format=lambda x: f"{x*10}%",
    range=range(11),
)
plt.show()
```

## Section 3: Pain points and challenges

```{python}
# | layout-ncol: 3

columns = [
    Column.S3_PERFORMANCE,
    Column.S3_DEBUGGING,
    Column.S3_LEGACY,
    Column.S3_HARDWARE,
    Column.S3_MEMORY,
    Column.S3_MEMORY_SAFETY,
    Column.S3_POWER,
    Column.S3_CERTIFICATION,
    Column.S3_TOOLING,
]

for column in columns:
    values = df[column]
    df_out[column] = values

    plot_hist(
        values,
        sort_by_index=True,
        range=range(1, 6),
        xlabel=column.value,
    )
    plt.show()
```

## Section 4: Language selection criteria

```{python}
# | layout-ncol: 3

columns = [
    Column.S4_LIBRARIES,
    Column.S4_C_INTEROPERABILITY,
    Column.S4_MATURITY,
    Column.S4_PERFORMANCE,
    Column.S4_MEMORY_SAFETY,
    Column.S4_COMMUNITY,
    Column.S4_TRAINING,
    Column.S4_TOOLING,
]

for column in columns:
    values = df[column]
    df_out[column] = values

    plot_hist(
        values,
        sort_by_index=True,
        range=range(1, 6),
        xlabel=column.value,
    )
    plt.show()
```

## Section 5: Modern language adoption

### Modern language use

```{python}
# | echo: false
# | output: 'asis'

column = Column.S5_DID_USE_MODERN
print(f"*{column.value}*")
```

```{python}
values = df[column]
df_out[column] = values

plot_pie(values)
plt.show()
```

### Barriers

```{python}
# | echo: false
# | output: 'asis'

column = Column.S5_BARRIERS
print(f"*{column.value}*")
```

```{python}
values = df[column].str.split(";")

values = preprocess(
    values,
    replace={
        "No need for such language in the workflow": "No need",
        "no need to": "No need",
        "Don't see the need for any of these languages. C can do all I need.": "No need",
        "Satisfied with existing tools no nee to look elsewhere": "No need",
        "No significant benefits": "No need",
        "C works": "No need",
        "Irrelevance": "No need",
        "doesn't seem worth the effort for most of our needs": "Not worth trying",
        "Makes no sense to waste time in something which is 99% likely unnecessary hype, does not solve actual problems, solves non-problems, and introduces new problems, only to be forgotten in 1-2 more years like happened to Rust already": "Not worth trying",
        "Lack of time - it is faster for me to write in C, especially when there is many projects in a backlog": "Not worth trying",
        "I want my code to build and work the same after 30 years.": "Lack of mature toolchain",
        "Resourse constraints": "Insufficient performance",
        "code size, compilation time (Rust), obstacles to breaking abstraction layers, lack of code portability across 8/16/32/64 bit and older or non-mainstream ISAs, coding speed": [
            "Insufficient performance",
            "Insufficient producivity",
            "Insufficient portability",
        ],
        "lightness of C": "Insufficient performance",
        "Fear of insufficient performance": "Insufficient performance",
        "Difficulty of integrating into existing codebase": "Difficulty of integrating\n...into existing codebase",
        "Insufficient libraries/driver support": "Insufficient libraries\n.../driver support",
    },
    drop=[
        "Both are terrible languages with horrific syntax",
        "Yes, I have used it and scrapped it for these reasons. It was a mess.",
    ],
)
df_out[column] = values

plot_hist(values, rotation=True)
plt.show()
```

### How likely to adopt

```{python}
# | echo: false
# | output: 'asis'

column = Column.S5_MODERN_ADOPTION
print(f"*{column.value}*")
```

```{python}
values = df[column]
df_out[column] = values

plot_hist(values, sort_by_index=True, range=range(1, 6))
plt.show()
```

## Section 6: Tooling and ecosystem

### C/C++ build system satisfaction

```{python}
# | echo: false
# | output: 'asis'

column = Column.S6_BUILD_SYSTEM_SATISFACTION
print(f"*{column.value}*")
```

```{python}
values = df[column]
df_out[column] = values

plot_hist(values, sort_by_index=True, range=range(1, 6))
plt.show()
```

### C/C++ static analysis reliance

```{python}
# | echo: false
# | output: 'asis'

column = Column.S6_STATIC_ANALYSIS_RELIANCE
print(f"*{column.value}*")
```

```{python}
values = df[column]
df_out[column] = values

plot_hist(values, sort_by_index=True, range=range(1, 6))
plt.show()
```

### C/C++ static analysis satisfaction

```{python}
# | echo: false
# | output: 'asis'

column = Column.S6_STATIC_ANALYSIS_SATISFACTION
print(f"*{column.value}*")
```

```{python}
values = df[column]
df_out[column] = values

plot_hist(values, sort_by_index=True, range=range(1, 6))
plt.show()
```

## Section 7: Open section

```{python}
# | echo: false


def print_comments(
    series: "pd.Series[str]", *, tags: "pd.Series[list[str]] | None" = None
):
    if tags is None:
        tags = pd.Series([[] for _ in range(len(series))])
    df = pd.concat([series, tags], axis=1)
    for _, row in df[~series.isna()].iterrows():
        [comment, comment_tags] = row
        comment: str
        comment_tags: list[str]
        lines = comment.splitlines()
        for line in lines:
            print(f"> {line}")
        print("")
        if comment_tags:
            print(f"*tags: {",".join(comment_tags)}*")
            print("")


def tag_comments(series: "pd.Series[str]", pattern_to_tags: dict[str, list[str]]):
    empty_data: list[list[str]] = [[] for _ in range(len(series))]
    tags = pd.Series(empty_data, index=series.index)
    for pattern, pattern_tags in pattern_to_tags.items():
        mask = series.str.match(pattern)
        mask[mask.isna()] = False
        found = mask.sum()
        if found != 1:
            raise Exception(
                f"Pattern '{pattern}' found {found} times, expected exactly 1"
            )
        [index] = tags.index[mask]
        tags.at[index] = pattern_tags
    return tags


def print_tags(tags: "pd.Series[list[str]]"):
    tag_counts = tags.explode().value_counts()
    print("Tag|Mentions")
    print("-|-")
    for tag, count in tag_counts.items():
        print(f"{tag}|{count}")
    print("")
```

### Wanted features

```{python}
# | echo: false
# | output: 'asis'

column = Column.S7_WANTED_FEATURES
print(f"*{column.value}*")
```

```{python}
# | output: 'asis'

values = df[column]
values = values.replace(
    {
        "No": pd.NA,
        "I am the tool creator (Astrobe IDE, Oberon language) so it's not relevant": pd.NA,
        "Right now not really": pd.NA,
    }
)
df_out[column] = values


debugging = r"debugging"
documentation = r"documentation"
simulation = r"simulation"
portability = r"portability"
compile_time = r"compile time"
microcontroller_diagnostics = r"microcontroller diagnostics"
build_system = r"better build system"
testing = r"better testing environment"
own_tools = r"self-made tooling"
stability = r"stability"
performance = r"performance"
memory_safety = r"memory safety"
static_anaylsis = r"static analysis"
certification = r"certification"

tags = tag_comments(
    values,
    {
        r"^esp-idf is best of the best frameworks i ever use": [documentation],
        r"^Built in unit test, and integration tests$": [testing],
        r"^Good stack frame introspection": [debugging, memory_safety],
        r"^robust build system that is integrated with the": [
            build_system,
            static_anaylsis,
            compile_time,
        ],
        r"^You didn\'t ask about portability to other hardware.": [
            portability,
            debugging,
            certification,
        ],
        r"^Cycle accurate simulation.$": [simulation],
        r"^A better IDE, multiplatform, good debugging tool": [portability, debugging],
        r"^power usage diagnostics, stats for light/deep sleep": [
            microcontroller_diagnostics
        ],
        r"^memory leak checker": [debugging],
        r"^Well integrated documentation for tools": [documentation],
        r"^Better simulators to develop natively on desktops.$": [simulation],
        r"^Improved debugging support for c++": [debugging],
        r"^KISS principle, self-made tooling for the actual": [own_tools],
        r"^Debugging without affecting realtime performance.": [debugging],
        r"^Proper preprocessor. The biggest pain in C": [compile_time],
        r"^Long term stability": [stability],
        r"^documentation$": [documentation],
        r"^a more reliable volatile checking functionality, so": [debugging],
        r"^new build system / tools. Make and CMake": [build_system],
        r"^Porting software on different variant microcontroller": [portability],
    },
)

print_comments(values, tags=tags)
print_tags(tags)
```

### Comments

```{python}
# | echo: false
# | output: 'asis'

column = Column.S7_COMMENTS
print(f"*{column.value}*")
```

```{python}
# | output: 'asis'

values = df[column]
values = values.replace(
    {
        "/": pd.NA,
        "Th Astrobe website is at www.astrobe.com. It has been in use since 2008.": pd.NA,
        "No": pd.NA,
    }
)
df_out[column] = values

praise_c = "praise C"

tags = tag_comments(
    values,
    {
        r"^now i just can say that C is the best lang t": [praise_c],
        r"^My devices sells on thousands. Setting up production": [static_anaylsis],
        r"^let's go C99, it's like ipv4. We know it's not perfect": [praise_c],
    },
)

print_comments(values, tags=tags)
print_tags(tags)
```
