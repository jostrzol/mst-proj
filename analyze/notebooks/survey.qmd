---
title: "Survey analysis"
format:
  html: {}
  pdf:
    toc: true
    highlight-style: github
    fig-pos: 'h'
execute:
  echo: false
  code-fold: true
jupyter: python3
---

```{python}
# | echo: false

# pyright: reportUnusedCallResult=false
# pyright: reportUnknownVariableType=false

from collections.abc import Iterable
import os
from matplotlib.container import BarContainer
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import scienceplots as _  # pyright: ignore[reportMissingTypeStubs]

from enum import Enum
from pathlib import Path
from typing import Any, Literal, override
from matplotlib.axes import Axes
from IPython.display import display
from textwrap import wrap

from analyze.lib.plot import (
    figsize_rel,
    gray_shades,
    plot_hist,
    plot_hist_horiz,
    savefig,
    use_plot_style,
)
from analyze.lib.constants import PLOT_DIR

pd.options.mode.copy_on_write = True


def find_root_dir():
    start_path = Path(__file__).parent if "__file__" in globals() else Path.cwd()
    current = start_path
    while current != current.parent:
        if (current / ".git").exists():
            return current
        current = current.parent
    return start_path


ROOT_DIR = find_root_dir()
SURVEY_PATH = ROOT_DIR / "analyze/data/survey.csv"
OUT_DIR = PLOT_DIR / "survey"

os.chdir(ROOT_DIR)
OUT_DIR.mkdir(exist_ok=True)

use_plot_style()


class Column(Enum):
    "Columns in the survey dataframe"

    TIMESTAMP = "Timestamp"

    # Section 1: Demographics and role
    S1_INDUSTRY = "Industry segment"
    S1_ROLE = "Your primary role"

    # Section 2: Current language usage
    S2_LANGUAGES_USED = """Which programming languages do you currently use or have used in the past
    for microcontroller projects?"""
    S2_C_CPP_RATIO = "What ratio of your embedded codebase is in C/C++?"

    # Section 3: Pain points and challenges
    S3_PERFORMANCE = "Real‑time performance"
    S3_DEBUGGING = "Debugging microcontroller programs"
    S3_LEGACY = "Integration with legacy code"
    S3_HARDWARE = "Interacting with hardware"
    S3_MEMORY = "Memory constraints (binary size, RAM/flash usage)"
    S3_MEMORY_SAFETY = "Memory vulnerabilities (e.g. use after free, buffer overflows)"
    S3_POWER = "Power consumption management"
    S3_CERTIFICATION = "Safety certification (e.g. IEC 61508, ISO 26262)"
    S3_TOOLING = "Tooling complexity (e.g. build system)"

    # Section 4: Language selection criteria
    S4_LIBRARIES = "Availability of libraries"
    S4_C_INTEROPERABILITY = "Interoperability with C code"
    S4_MATURITY = "Maturity of compiler/toolchain"
    S4_PERFORMANCE = "Real-time performance"
    S4_MEMORY_SAFETY = "Safety of memory management"
    S4_COMMUNITY = "Strong community support"
    S4_TRAINING = "Team expertise and training cost"
    S4_TOOLING = "Tooling features and usability (e.g. build system)"

    # Section 5: Modern language adoption
    S5_DID_USE_MODERN = "Have you ever used any “modern” language (e.g. Rust, Zig) for embedded development?"
    S5_BARRIERS = "If not, what barriers prevent you?"
    S5_MODERN_ADOPTION = (
        "How likely are you to adopt any “modern” language in the next 12 months?"
    )

    # Section 6: Tooling and ecosystem
    S6_BUILD_SYSTEM_SATISFACTION = """Rate your satisfaction with the build system for C/C++ that you use for
    embedded projects."""
    S6_STATIC_ANALYSIS_RELIANCE = """How much do you rely on C/C++ static analysis tools for microcontroller
    code? (e.g. clang-tidy, MISRA checkers)"""
    S6_STATIC_ANALYSIS_SATISFACTION = """Rate your satisfaction with C/C++ static analysis tools for
    microcontroller code."""

    # Section 7: Open section
    S7_WANTED_FEATURES = """Can you think of any language or tooling features would most help your
    embedded development?"""
    S7_COMMENTS = "Any additional comments?"

    @override
    def __str__(self) -> str:
        return self.name
```

```{python}
df = pd.read_csv(SURVEY_PATH)
df.columns = [column for column in Column]
display(df)
total = len(df)
```

```{python}
# | echo: false


def preprocess(
    series: pd.Series,
    replace: dict[Any, Any | list[Any]] | None = None,
    drop: list[Any] | None = None,
) -> pd.Series:
    replace = replace or {}

    def replace_value(value: Any) -> list[Any]:
        replacement = replace.get(value, value)
        return replacement if isinstance(replacement, list) else [replacement]

    def preprocess_row(lst: list[Any]) -> list[Any]:
        series = pd.Series(lst)
        series = series.map(replace_value).explode()
        series = series[~series.isin(drop or [])]
        return series.to_list()

    return series.apply(preprocess_row)


def wrap_series(series: "pd.Series[str]", count: int = 22, sep: str = "\n"):
    def do_wrap(value: str) -> str:
        if pd.isna(value):
            return value
        return sep.join(wrap(value, count))

    return series.map(do_wrap)


def pd_plot_hist(
    series: pd.Series,
    ax: Axes | None = None,
    xrange: Iterable[Any] | None = None,
    rotation: bool | float = False,
    sort_by_index: bool = False,
    fontsize: int | None = None,
) -> BarContainer:
    return plot_hist(
        labels=series.to_list(),
        ax=ax,
        xrange=xrange,
        rotation=rotation,
        sort_by_index=sort_by_index,
        fontsize=fontsize,
    )


def pd_plot_hist_horiz(
    series: pd.Series,
    ax: Axes | None = None,
    yrange: Iterable[Any] | None = None,
    sort_by_index: bool = False,
    fontsize: int | None = None,
    xticks_side: Literal["left"] | Literal["right"] = "left",
) -> BarContainer:

    return plot_hist_horiz(
        labels=series.to_list(),
        ax=ax,
        yrange=yrange,
        sort_by_index=sort_by_index,
        fontsize=fontsize,
        xticks_side=xticks_side,
    )


def pd_plot_pie(
    series: pd.Series,
    label: str | None = None,
    fontsize: int | None = None,
    labeldistance: float | None = 1.1,
    pctdistance: float | None = 0.7,
) -> Axes:
    values = series.value_counts()
    total = values.sum()

    def fmt(percent: np.float64):
        count = (percent / 100 * total).astype(np.int64)
        return f"{count}\n({percent:.0f}%)"

    colors = gray_shades(len(values), shades="light")

    ax = values.plot(
        kind="pie",
        autopct=fmt,
        label=label or "",
        colors=colors,
        wedgeprops={"edgecolor": "black", "linewidth": 2},
        textprops={"fontsize": fontsize},
        labeldistance=labeldistance,
        pctdistance=pctdistance,
        explode=[0.05] * len(values),
    )

    return ax


def pd_savefig(series: pd.Series, dir: Path | str):
    assert series.name is not None
    savefig(plt.gcf(), Path(dir) / str(series.name))


ax: Axes
df_out = pd.DataFrame()
```

## Section 1: Demographics and role

### Industry segment

```{python}
column = Column.S1_INDUSTRY
values = df[column].str.split(";")


values = preprocess(
    values,
    replace={
        "Material Handling (Forklifts)": "Automotive",
        "Transport": "Automotive",
        "Silicon photonics and lasers": "Silicon production",
        "Fabless semiconductor company": "Silicon production",
        "Computer networking": "Networks",
        "Telecoms": "Networks",
        "IMS": "Networks",
        "Wireless charging": "Consumer electronics",
        "Stage lighting equipment": "Professional electronics",
        "Professionnel Photography/Lighting": "Professional electronics",
        "test and measurements": "Professional electronics",
        "Metering": "Professional electronics",
        "Datacenter": "Professional electronics",
        "Hobby": "Consumer electronics",
        "Scientific Research Instrumentation": "Research",
    },
    drop=["Software Development", "Open Source"],
)
values = preprocess(
    values,
    replace={
        "Consumer electronics": "Elektronika dla masowego klienta",
        "IoT / Edge Computing": "Internet rzeczy",
        "Industrial automation": "Automatyka",
        "Automotive": "Motoryzacja",
        "Medical devices": "Medycyna",
        "Aerospace": "Lotnictwo",
        "Professional electronics": "Elektronika profesjonalna",
        "Networks": "Sieci komputerowe",
        "Silicon production": "Układy scalone",
        "Energy": "Energia",
        "Defense": "Militaria",
        "Research": "Nauka",
    },
)
df_out[column] = values

plt.figure(figsize=figsize_rel(w=0.6))

to_plot = values
pd_plot_hist_horiz(to_plot)
pd_savefig(to_plot, OUT_DIR)
plt.show()
```

### Primary role

```{python}
column = Column.S1_ROLE
values = df[column]

values = preprocess(
    values,
    replace={
        "Hardware and Software": ["Software engineer", "Hardware engineer"],
        "Both hard and software (firmware)": ["Software engineer", "Hardware engineer"],
        "HW / SW engineer": ["Software engineer", "Hardware engineer"],
        "all of the above": [
            "Software engineer",
            "Hardware engineer",
            "System architect",
        ],
    },
)
values = preprocess(
    values,
    replace={
        "Software engineer": "Programista",
        "Hardware engineer": "Inżnier sprzętu",
        "System architect": "Architekt systemu",
    },
)
df_out[column] = values

to_plot = values.map(lambda row: ["\n".join(s.split()) for s in row])
plt.figure(figsize=figsize_rel(w=0.3))
pd_plot_hist(to_plot, rotation=True)
pd_savefig(to_plot, OUT_DIR)
plt.show()
```

## Section 2: Current language use

### Language use

```{python}
# | echo: false
# | output: 'asis'

column = Column.S2_LANGUAGES_USED
print(f"*{column.value}*")
```

```{python}
column = Column.S2_LANGUAGES_USED
values = df[column].str.split(";")

values = preprocess(
    values,
    replace={
        "JavaScript / TypeScript (e.g. Espruino)": "JavaScript / TypeScript",
        "Assembler": "Assembly",
        "Bash": "Shell scripts",
        "scheme, forth, Dylan": ["Scheme", "Forth", "Dylan"],
    },
)
df_out[column] = values

to_plot = values
pd_plot_hist(to_plot, rotation=True)
pd_savefig(to_plot, OUT_DIR)
plt.show()
```

Obserwacje

```{python}
# | output: asis
has_c = values.map(lambda row: "C" in row or "C++" in row).sum()
percent = has_c / total * 100
print(f"* Odpowiedzi z zaznaczonym C lub C++: {has_c}/{total} ({percent:.0f}%)")
```

### Codebase

```{python}
# | echo: false
# | output: 'asis'

column = Column.S2_C_CPP_RATIO
print(f"*{column.value}*")
```

```{python}
column = Column.S2_C_CPP_RATIO
values = df[column]
df_out[column] = values

to_plot = values
plt.figure(figsize=figsize_rel(h=0.8))
ax = plt.axes()
pd_plot_hist(
    to_plot,
    ax=ax,
    rotation=True,
    sort_by_index=True,
    xrange=[*range(11)],
)
xticks = ax.get_xticks()
ax.set_xticks(xticks, [f"{t*10}%" for t in xticks])
pd_savefig(to_plot, OUT_DIR)

avg = to_plot.mean() * 10
ax.set_xlabel(f"{avg:.2f}% avg")
plt.show()
```

## Section 3: Pain points and challenges

```{python}
# | layout-ncol: 3

columns = [
    Column.S3_HARDWARE,
    Column.S3_PERFORMANCE,
    Column.S3_MEMORY,
    Column.S3_DEBUGGING,
    Column.S3_MEMORY_SAFETY,
    Column.S3_TOOLING,
    Column.S3_POWER,
    Column.S3_LEGACY,
    Column.S3_CERTIFICATION,
]

for column in columns:
    values = df[column]
    df_out[column] = values

    to_plot = values
    plt.figure(figsize=figsize_rel(0.3, 0.6))
    pd_plot_hist(
        to_plot,
        sort_by_index=True,
        xrange=range(1, 6),
    )
    pd_savefig(to_plot, OUT_DIR)

    avg = to_plot.mean()
    xlabel = ("\n".join(wrap(f"{column.value} ({avg:.3} avg)", 22)),)
    plt.show()
```

## Section 4: Language selection criteria

```{python}
# | layout-ncol: 3

columns = [
    Column.S4_MATURITY,
    Column.S4_PERFORMANCE,
    Column.S4_C_INTEROPERABILITY,
    Column.S4_TOOLING,
    Column.S4_MEMORY_SAFETY,
    Column.S4_TRAINING,
    Column.S4_LIBRARIES,
    Column.S4_COMMUNITY,
]

for column in columns:
    values = df[column]
    df_out[column] = values

    to_plot = values
    plt.figure(figsize=figsize_rel(0.3, 0.6))
    pd_plot_hist(
        to_plot,
        sort_by_index=True,
        xrange=range(1, 6),
    )
    pd_savefig(to_plot, OUT_DIR)

    avg = to_plot.mean()
    xlabel = "\n".join(wrap(f"{column.value} ({avg:.3} avg)", 22))
    ax.set_xlabel(xlabel)
    plt.show()
```

## Section 5: Modern language adoption

### Modern language use

```{python}
# | echo: false
# | output: 'asis'

column = Column.S5_DID_USE_MODERN
print(f"*{column.value}*")
```

```{python}
values = df[column]
values = preprocess(
    values,
    replace={
        "Yes": "Tak",
        "No": "Nie",
    },
)
df_out[column] = values

to_plot = values.explode()
plt.figure(figsize=figsize_rel(w=0.2))
pd_plot_hist(to_plot)
pd_savefig(to_plot, OUT_DIR)
plt.show()
```

### Barriers

```{python}
# | echo: false
# | output: 'asis'

column = Column.S5_BARRIERS
print(f"*{column.value}*")
```

```{python}
values = df[column].str.split(";")

values = preprocess(
    values,
    replace={
        "No need for such language in the workflow": "No need",
        "no need to": "No need",
        "Don't see the need for any of these languages. C can do all I need.": "No need",
        "Satisfied with existing tools no nee to look elsewhere": "No need",
        "No significant benefits": "No need",
        "C works": "No need",
        "Irrelevance": "No need",
        "doesn't seem worth the effort for most of our needs": "Not worth trying",
        "Makes no sense to waste time in something which is 99% likely unnecessary hype, does not solve actual problems, solves non-problems, and introduces new problems, only to be forgotten in 1-2 more years like happened to Rust already": "Not worth trying",
        "Lack of time - it is faster for me to write in C, especially when there is many projects in a backlog": "Not worth trying",
        "I want my code to build and work the same after 30 years.": "Lack of mature toolchain",
        "Resourse constraints": "Insufficient performance",
        "code size, compilation time (Rust), obstacles to breaking abstraction layers, lack of code portability across 8/16/32/64 bit and older or non-mainstream ISAs, coding speed": [
            "Insufficient performance",
            "Insufficient producivity",
            "Insufficient portability",
        ],
        "lightness of C": "Insufficient performance",
        "Fear of insufficient performance": "Insufficient performance",
    },
    drop=[
        "Both are terrible languages with horrific syntax",
        "Yes, I have used it and scrapped it for these reasons. It was a mess.",
    ],
)

values = preprocess(
    values,
    replace={
        "Difficulty of integrating into existing codebase": "Trudna integracja z istniejącym kodem",
        "Team unfamiliarity": "Brak ekspertyzy zespołu",
        "Lack of mature toolchain": "Brak dojrzałości języka",
        "Insufficient performance": "Gorsza wydajność",
        "Insufficient libraries/driver support": "Brak bibliotek, sterowników",
        "Insufficient producivity": "Gorsza produktywność",
        "Insufficient portability": "Gorsza przenośność",
        "No need": "Brak potrzeby zmian",
        "Not worth trying": "Nie opłaca się próbować",
        "Certification concerns": "Obawy przed certyfikacją",
    },
)
df_out[column] = values

to_plot = values.explode()
plt.figure(figsize=figsize_rel(w=0.7))
pd_plot_hist_horiz(to_plot, xticks_side="right")
pd_savefig(to_plot, OUT_DIR)
plt.show()
```

### How likely to adopt

```{python}
# | echo: false
# | output: 'asis'

column = Column.S5_MODERN_ADOPTION
print(f"*{column.value}*")
```

```{python}
values = df[column]
df_out[column] = values

to_plot = values
plt.figure(figsize=figsize_rel(0.3, 0.6))
pd_plot_hist(to_plot, sort_by_index=True, xrange=range(1, 6))
pd_savefig(to_plot, OUT_DIR)
plt.show()
```

## Section 6: Tooling and ecosystem

### C/C++ build system satisfaction

```{python}
# | echo: false
# | output: 'asis'

column = Column.S6_BUILD_SYSTEM_SATISFACTION
print(f"*{column.value}*")
```

```{python}
values = df[column]
df_out[column] = values

to_plot = values
plt.figure(figsize=figsize_rel(0.3, 0.6))
pd_plot_hist(to_plot, sort_by_index=True, xrange=range(1, 6))
pd_savefig(to_plot, OUT_DIR)
plt.show()
```

### C/C++ static analysis reliance

```{python}
# | echo: false
# | output: 'asis'

column = Column.S6_STATIC_ANALYSIS_RELIANCE
print(f"*{column.value}*")
```

```{python}
values = df[column]
df_out[column] = values

to_plot = values
plt.figure(figsize=figsize_rel(0.3, 0.6))
pd_plot_hist(to_plot, sort_by_index=True, xrange=range(1, 6))
pd_savefig(to_plot, OUT_DIR)
plt.show()
```

### C/C++ static analysis satisfaction

```{python}
# | echo: false
# | output: 'asis'

column = Column.S6_STATIC_ANALYSIS_SATISFACTION
print(f"*{column.value}*")
```

```{python}
values = df[column]
values[values.isna()] = 0
df_out[column] = values

to_plot = values[~values.isna()].astype(np.int8)
plt.figure(figsize=figsize_rel(0.3, 0.6))
pd_plot_hist(to_plot, sort_by_index=True, xrange=range(0, 6))
pd_savefig(to_plot, OUT_DIR)
plt.show()
```

```{python}
reliance = df_out[Column.S6_STATIC_ANALYSIS_RELIANCE]
reliant = values[reliance > 3]
values = reliant

to_plot = values[~values.isna()].astype(np.int8)
plt.figure(figsize=figsize_rel(0.3, 0.6))
pd_plot_hist(to_plot, sort_by_index=True, xrange=range(1, 6))
plt.show()
```

## Section 7: Open section

```{python}
# | echo: false


def print_comments(
    series: "pd.Series[str]", *, tags: "pd.Series[list[str]] | None" = None
):
    if tags is None:
        tags = pd.Series([[] for _ in range(len(series))])
    df = pd.concat([series, tags], axis=1)
    for _, row in df[~series.isna()].iterrows():
        [comment, comment_tags] = row
        comment: str
        comment_tags: list[str]
        lines = comment.splitlines()
        for line in lines:
            print(f"> {line}")
        print("")
        if comment_tags:
            print(f"*tags: {",".join(comment_tags)}*")
            print("")


def tag_comments(series: "pd.Series[str]", pattern_to_tags: dict[str, list[str]]):
    empty_data: list[list[str]] = [[] for _ in range(len(series))]
    tags = pd.Series(empty_data, index=series.index)
    for pattern, pattern_tags in pattern_to_tags.items():
        mask = series.str.match(pattern)
        mask[mask.isna()] = False
        found = mask.sum()
        if found != 1:
            raise Exception(
                f"Pattern '{pattern}' found {found} times, expected exactly 1"
            )
        [index] = tags.index[mask]
        tags.at[index] = pattern_tags
    return tags


def print_tags(tags: "pd.Series[list[str]]"):
    tag_counts = tags.explode().value_counts()
    print("Tag|Mentions")
    print("-|-")
    for tag, count in tag_counts.items():
        print(f"{tag}|{count}")
    print("")
```

### Wanted features

```{python}
# | echo: false
# | output: 'asis'

column = Column.S7_WANTED_FEATURES
print(f"*{column.value}*")
```

```{python}
# | output: 'asis'

values = df[column]
values = values.replace(
    {
        "No": pd.NA,
        "I am the tool creator (Astrobe IDE, Oberon language) so it's not relevant": pd.NA,
        "Right now not really": pd.NA,
    }
)
df_out[column] = values


debugging = r"debugging"
documentation = r"documentation"
simulation = r"simulation"
portability = r"portability"
compile_time = r"compile time"
microcontroller_diagnostics = r"microcontroller diagnostics"
build_system = r"better build system"
testing = r"better testing environment"
own_tools = r"self-made tooling"
stability = r"stability"
memory_safety = r"memory safety"
static_anaylsis = r"static analysis"
certification = r"certification"

tags = tag_comments(
    values,
    {
        r"^esp-idf is best of the best frameworks i ever use": [documentation],
        r"^Built in unit test, and integration tests$": [testing],
        r"^Good stack frame introspection": [debugging, memory_safety],
        r"^robust build system that is integrated with the": [
            build_system,
            static_anaylsis,
            compile_time,
        ],
        r"^You didn\'t ask about portability to other hardware.": [
            portability,
            debugging,
            certification,
        ],
        r"^Cycle accurate simulation.$": [simulation],
        r"^A better IDE, multiplatform, good debugging tool": [portability, debugging],
        r"^power usage diagnostics, stats for light/deep sleep": [
            microcontroller_diagnostics
        ],
        r"^memory leak checker": [debugging],
        r"^Well integrated documentation for tools": [documentation],
        r"^Better simulators to develop natively on desktops.$": [simulation],
        r"^Improved debugging support for c++": [debugging],
        r"^KISS principle, self-made tooling for the actual": [own_tools],
        r"^Debugging without affecting realtime performance.": [debugging],
        r"^Proper preprocessor. The biggest pain in C": [compile_time],
        r"^Long term stability": [stability],
        r"^documentation$": [documentation],
        r"^a more reliable volatile checking functionality, so": [debugging],
        r"^new build system / tools. Make and CMake": [build_system],
        r"^Porting software on different variant microcontroller": [portability],
    },
)

print_comments(values, tags=tags)

tags.name = Column.S7_WANTED_FEATURES
tags = preprocess(
    tags,
    replace={
        debugging: r"lepsze debugowanie",
        documentation: r"lepsza dokumentacja",
        simulation: r"symulacja sprzętu",
        portability: r"przenośność",
        compile_time: r"obliczenia w czasie kompilacji",
        microcontroller_diagnostics: r"diagnostyka sprzętu",
        build_system: r"lepszy system budowania",
        testing: r"lepsze możliwości testowania",
        # own_tools: r"tworzenie własnych narzędzi",
        stability: r"stabilność środowiska",
        memory_safety: r"zabezpieczenia przed błędami pamięci",
        static_anaylsis: r"statyczna analiza",
        # certification: r"certyfikacja",
    },
    drop=[own_tools, certification],
)

to_plot = tags.explode()
pd_plot_hist_horiz(to_plot)
pd_savefig(to_plot, OUT_DIR)
```

### Comments

```{python}
# | echo: false
# | output: 'asis'

column = Column.S7_COMMENTS
print(f"*{column.value}*")
```

```{python}
# | output: 'asis'

values = df[column]
values = values.replace(
    {
        "/": pd.NA,
        "Th Astrobe website is at www.astrobe.com. It has been in use since 2008.": pd.NA,
        "No": pd.NA,
    }
)
df_out[column] = values

praise_c = "praise C"

tags = tag_comments(
    values,
    {
        r"^now i just can say that C is the best lang t": [praise_c],
        r"^My devices sells on thousands. Setting up production": [static_anaylsis],
        r"^let's go C99, it's like ipv4. We know it's not perfect": [praise_c],
    },
)

print_comments(values, tags=tags)
print_tags(tags)
```
